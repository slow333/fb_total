<!DOCTYPE html>
<html lang="en">
<head>
  <script src="/js/menu/loadNav.js"></script>
</head>
<body>
<main>

<!--*********** STORED PROCECURE: 자주 쓰는 SQL을 함수로 저장 ******************-->
<h1>STORED PROCEDURE</h1>
<h3>STORED PROCECURE: 자주 쓰는 SQL을 함수로 저장</h3>
<pre>
DELIMITER $$ -- delimiter 를 $$ 임시로 변경 procedure에서 ;를 쓸 수 있도록 함
CREATE PROCEDURE procedure_name ()
BEGIN
    -- SQL statements
    SELECT * FROM table_name;
    -- Other SQL statements
END $$
DELIMITER ; -- 다시 delimiter를 ;로 변경
-- 프로시저 호출
CALL procedure_name('value1', @output);
-- --------------------------------------
-- 프로시저에 OUT 파라미터가 있는 경우, @output 변수에 결과를 저장함
DELIMITER $$
CREATE PROCEDURE procedure_name (IN param1 datatype, OUT param2 datatype)
BEGIN
  SELECT * FROM table_name WHERE column_name = param1;
  SET param2 = (SELECT COUNT(*) FROM table_name WHERE column_name = param1);
END $$
DELIMITER ;
CALL procedure_name('value1', @output);
-- --------------------------------------
DELIMITER $$
CREATE PROCEDURE find_customer (IN id INT)
BEGIN
  SELECT * FROM customers WHERE customer_id = id;
END $$
DELIMITER ;
CALL find_customer(1); -- 프로시저 호출
-- --------------------------------------
DELIMITER $$
CREATE PROCEDURE find_customer_full_name (IN f_name VARCHAR(50), IN l_name VARCHAR(50))
BEGIN
  SELECT * FROM customers where first_name = f_name AND last_name = l_name;
END $$
DELIMITER ;
CALL find_customer_full_name("abc", "cde"); -- 프로시저 호출

DROP PROCEDURE IF EXISTS procedure_name; -- 프로시저 삭제
</pre>
<!--*********** TRIGGERS ******************-->
<h1>TRIGGERS</h1>
<h3>뭔가를 한 후에 수행할 주로 업데이트할 내용을 정의</h3>
<pre>
SHOW TRIGGERS; -- 트리거 목록 보기
DROP TRIGGER IF EXISTS trigger_name; -- 트리거 삭제
-- ########## 트리거 생성 #############
CREATE TRIGGER trigger_name
BEFORE|AFTER INSERT|UPDATE|DELETE ON table_name
FOR EACH ROW
BEGIN
  INSERT INTO log_table (action, action_time) VALUES ('insert', NOW());
END;  
</pre>
<pre>--exercise
  ALTER TABLE employees
  ADD COLUMN salary DECIMAL(10, 2) NOT NULL DEFAULT 0.00
  AFTER hourly_pay;
  UPDATE employees
  SET salary = hourly_pay * 40 * 4; -- 월급으로 변환
  -- ########## 트리거 생성 hourly_pay가 변경되면 salary도 변경되도록 함
  CREATE TRIGGER before_hourly_pay_update
  BEFORE UPDATE ON employees
  FOR EACH ROW
    SET NEW.salary = NEW.hourly_pay * 40 * 4; -- 월급으로 변환
  -- ########## 트리거 생성 hourly_pay가 변경되면 salary도 변경되도록 함    
  CREATE TRIGGER before_hourly_pay_insert
  BEFORE INSERT ON employees
  FOR EACH ROW
    SET NEW.salary = NEW.hourly_pay * 40 * 4; -- 월급으로 변환

  insert into employees values(29, "신입","직원", "worker", 18, null, DATE(NOW()), 3);
</pre>
<h3>예제</h3>
<pre>
CREATE TABLE IF NOT EXISTS expenses (
  id INT AUTO_INCREMENT PRIMARY KEY,
  expense_name varchar(20),
  expense_total INT
);
UPDATE expenses 
  SET expense_total = (SELECT SUM(salary) FROM employees) 
  WHERE expense_name = "salaries";
-- ########## 행이 추가허면 업데이트 하는 트리거
CREATE TRIGGER after_salary_insert_expense_total
AFTER INSERT ON employees
FOR EACH ROW
  UPDATE expenses 
  SET expense_total = expense_total + NEW.salary 
  WHERE expense_name = "salaries";

-- ########## 행이 삭제하면 업데이트 하는 트리거 생성
CREATE TRIGGER after_salary_delete_expense_total
AFTER DELETE ON employees -- BEFORE로 하면 삭제된 행이 없어서 에러 발생
FOR EACH ROW
  UPDATE expenses 
  SET expense_total = expense_total - OLD.salary -- OLD.salary는 삭제되는 행의 salary
  WHERE expense_name = "salaries";

-- --------------------------------------
-- update해서 값이 변경되었을 때  
CREATE TRIGGER after_salary_update_expense_total
AFTER UPDATE ON employees -- BEFORE로 하면 삭제된 행이 없어서 에러 발생
FOR EACH ROW
  UPDATE expenses 
  SET expense_total = expense_total + (NEW.salary - OLD.salary) -- 새로운 값에서 이전 값을 뺌
  WHERE expense_name = "salaries";
</pre>
<!--*********** 문자 함수 관련 ******************-->
<h1>문자 관련 함수</h1>

<h2>trim</h2>
<pre>SELECT TRIM('  Hello World!  '); -- 'Hello World!'
SELECT TRIM(LEADING ' ' FROM '  Hello World!  '); -- 'Hello World!  ' 
SELECT TRIM(TRAILING '*' FROM '  Hello World!****'); -- '  Hello World!'</pre>  

<h2>concat</h2>
<pre>SELECT CONCAT('Hello', ' ', 'World!'); -- 'Hello World!'
SELECT CONCAT('Hello', ' ', 'World!', 123); -- 'Hello World!123'</pre>

<h2>concat_ws</h2>
<pre>SELECT CONCAT_WS('-', '2023', '10', '01'); -- '2023-10-01'</pre>

<h2>substring</h2>
<pre>SELECT SUBSTRING('Hello World!', 1, 5); -- 'Hello'</pre>

<h2>replace</h2>
<pre>SELECT REPLACE('Hello World!', 'World', 'MySQL'); -- 'Hello MySQL!'</pre>

<h2>instr, locate: index of string</h2>
<pre>SELECT INSTR('Hello World!', 'World'); -- 7 (찾은 문자열의 시작 위치)

SELECT LOCATE('World', 'Hello World!'); -- 7 (찾은 문자열의 시작 위치)
SELECT LOCATE('World', 'Hello World!', 8); -- 0 (8번째 이후에 찾지 못함)</pre>

<h2>upper, lower</h2>
<pre>SELECT UPPER('Hello World!'); -- 'HELLO WORLD!'
SELECT LOWER('Hello World!'); -- 'hello world!'</pre>

<h2>length</h2>
<pre>SELECT LENGTH('Hello World!'); -- 13</pre>

<h2>Left pad, Right pad</h2>
<pre>SELECT LPAD('Hello', 10, '*'); -- '*****Hello'
SELECT RPAD('Hello', 10, '*'); -- 'Hello*****'</pre>

<h2>coalesce</h2>
<pre>SELECT COALESCE(NULL, 'Hello', 'World'); -- 'Hello'
SELECT COALESCE(NULL, NULL, 'World'); -- 'World'
SELECT COALESCE(NULL, NULL, NULL); -- NULL</pre>

<!--*********** 조건 절 ******************-->
<h1>조건 절</h1>
<h2>if: 2가지 선택 </h2>
<pre>SELECT IF(1 &gt; 0, '참입니다.', '거짓입니다.');</pre>

<h2>case: 2가지 이상의 경우에...</h2>
<pre>SELECT CASE WHEN 1 &gt; 0 THEN 'True' ELSE 'False' END; -- 'True'
SELECT CASE 
  WHEN 가격 &gt; 30 THEN '비싸요' 
  WHEN 가격 &lt;= 30 THEN '저렴해요' 
  ELSE '가격 정보 없음'
END;</pre>

<h2>ifnull; null 일때 기본값 지정</h2>
<pre>SELECT IFNULL(NULL, 'Hello'); -- 'Hello'
SELECT IFNULL('Hello', 'World'); -- 'Hello'</pre>

<h2>nullif: 2개의 값이 같으면 null, 아니면 첫번째 값</h2>
<pre>SELECT NULLIF('Hello', 'Hello'); -- NULL
SELECT NULLIF('Hello', 'World'); -- 'Hello'</pre>

<!--*********** 수학 함수 ******************-->
<h1>수학 함수</h1>
<h2>format; 숫자를 지정된 형식으로 포맷</h2>
<pre>SELECT FORMAT(1234567.89, 2); -- '1,234,567.89'</pre>

<h2>round; 숫자를 반올림</h2>
<pre>SELECT ROUND(123.4567, 2); -- 123.46
SELECT ROUND(123.4567); -- 123
FLOOR(i + RAND() * (J - I); -- I와 J 사이의 정수
update car set car.customer_id = FLOOR(rand()*10 + 1); -- 1~ 10의 값</pre>

<h2>rand; 랜덤 숫자 생성</h2>
<pre>SELECT RAND(); -- 0과 1 사이의 랜덤 숫자
SELECT RAND(123); -- 123을 시드로 사용하여 랜덤 숫자 생성</pre>

<h2>pi; 원주율 반환</h2>
<pre>SELECT PI(); -- 3.141592653589793</pre>

<h2>ceil; 숫자를 올림</h2>
<pre>SELECT CEIL(123.4567); -- 124
SELECT CEIL(-123.4567); -- -123</pre>

<h2>floor; 숫자를 내림</h2>
<pre>SELECT FLOOR(123.4567); -- 123
SELECT FLOOR(-123.4567); -- -124</pre>

<h2>mod; 나머지 연산</h2>
<pre>SELECT MOD(10, 3); -- 1
SELECT 7 $ 2; -- 1</pre>

<h2>abs; 절대값</h2>
<pre>SELECT ABS(-123.4567); -- 123.4567
SELECT ABS(123.4567); -- 123.4567</pre>

<h2>sign; 숫자의 부호 반환</h2>
<pre>SELECT SIGN(-123.4567); -- -1
SELECT SIGN(0); -- 0
SELECT SIGN(123.4567); -- 1</pre>

<h2>greatest, least</h2>
<pre>SELECT GREATEST(1, 2, 3); -- 3
SELECT LEAST(1, 2, 3); -- 1</pre>

<h2>convert: cast type</h2>
<pre>SELECT CONVERT('123.4567', DECIMAL(10, 2)); -- 123.46
SELECT CAST('123.4567' AS DECIMAL(10, 2)); -- 123.46
SELECT CONVERT('2023-10-01', DATE); -- '2023-10-01'
SELECT CAST('2023-10-01' AS DATE); -- '2023-10-01'
SELECT CONVERT('01', DECIMAL); -- INT는 안됨
SELECT CAST(003 AS CHAR); -- '3'
SELECT '01' = '1', CONVERT('01', DECIMAL) = CONVERT('1', DECIMAL);</pre>

<!--*********** 시스템 함수 관련 ******************-->
<h1>시스템 함수</h1>
<h2>version; MySQL 버전 반환</h2>
<pre>SELECT VERSION(); -- MySQL 서버 버전 반환</pre>

<h2>user; 현재 사용자 반환</h2>
<pre>SELECT USER(); -- 현재 사용자 반환</pre>

<h2>current_user; 현재 사용자 반환</h2>
<pre>SELECT CURRENT_USER(); -- 현재 사용자 반환</pre>

<h2>database; 현재 데이터베이스 반환</h2>
<pre>SELECT DATABASE(); -- 현재 데이터베이스 반환</pre>

<h2>schema; 현재 스키마 반환</h2>
<pre>SELECT SCHEMA(); -- 현재 스키마 반환</pre>

<!--*********** 시간, 날짜 함수 관련 ******************-->
<h1>DATE, TIME</h1>
<pre>
CURDATE(), CURRENT_DATE(), CURRENT_DATE; -- 현재 날짜 반환
CURTIME(), CURRENT_TIME(), CURRENT_TIME; -- 현재 시간 반환
NOW(), CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP; -- 현재 날짜와 시간 반환
SYSDATE(), SYSDATE; -- 현재 날짜와 시간 반환
</pre>

<h2>date_format</h2>
<pre>SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s'); -- '2023-10-01 12:34:56'</pre>

<h2>날짜 관련 데이터 추출하기</h2>
<pre>DATE | TIME | YEAR | MONTH | DAY = DAYOFMONTH('2023-10-01 12:34:56')
  DATENAME | MONTHNAME | WEEKDAY ('2023-10-01 12:34:56')
  HOUR | MINUTE | SECOND('2023-10-01 12:34:56');
-- 현재 날짜, 시간, 년, 월, 일, 시, 분, 초 반환
DATE(NOW()) / TIME(NOW()) / YEAR(NOW()) / MONTH(NOW()) / DAY(NOW()) 
/ HOUR(NOW()) / MINUTE(NOW()) / SECOND(NOW());

CONCAT_WS(' ', DATE(NOW()), TIME(NOW())); -- '2023-10-01 12:34:56'
</pre>

<h2>EXTRACT ; 날짜에서 특정 부분 추출</h2>
<pre>EXTRACT(YEAR|MONTH|DAY FROM '2023-10-01');</pre>

<h2>차이 계산</h2>
<pre>SELECT DATEDIFF('2023-10-01', '2023-09-01'); -- 30
SELECT TIMESTAMPDIFF(DAY | MONTH | YEAR, '2023-10-01', '2002-09-01');

SELECT name, birth, CURDATE(), TIMESTAMPDIFF(YEAR, birth, CURDATE()) AS age
FROM employees WHERE birth IS NOT NULL;</pre>

<h2>date_add; 날짜에 시간 더하기</h2>
<pre>SELECT DATE_ADD | ADDDATE('2023-10-01', INTERVAL 1 DAY); -- '2023-10-02'
SELECT DATE_ADD('2023-10-01', INTERVAL 1 MONTH); -- '2023-11-01'</pre>

<h2>date_sub; 날짜에서 시간 빼기</h2>
<pre>SELECT DATE_SUB | SUBDATE('2023-10-01', INTERVAL 1 DAY); -- '2023-09-30'
SELECT DATE_SUB('2023-10-01', INTERVAL 1 MONTH); -- '2023-09-01'</pre>

<h2>unix_timestamp; 현재 시간을 유닉스 타임스탬프로 반환</h2>
<pre>SELECT UNIX_TIMESTAMP(); -- 현재 시간을 유닉스 타임스탬프로 반환
SELECT UNIX_TIMESTAMP('2023-10-01 12:00:00'); -- 특정 시간을 유닉스 타임스탬프로 반환</pre>

<h2>from_unixtime; 유닉스 타임스탬프를 날짜로 변환</h2>
<pre>SELECT FROM_UNIXTIME(UNIX_TIMESTAMP()); -- 현재 시간을 날짜로 변환
SELECT FROM_UNIXTIME(1696129200); -- 특정 유닉스 타임스탬프를 날짜로 변환</pre>

<h2>utc_date, UTC_TIME ; UTC 반환</h2>
<pre>SELECT UTC_DATE(); -- UTC 날짜 반환
SELECT UTC_TIME(); -- UTC 시간 반환</pre>

</main>
</body>
</html>
